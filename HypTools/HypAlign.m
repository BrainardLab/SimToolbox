function HypAlign(rawImageDir,alignImageDir,...    width,height,useWidth,useHeight,alignColOffset,alignRowOffset,type, ...		  originalPlatform,rawImageRoot)% HypAlign(rawImageDir,alignImageDir,...%   width,height,useWidth,useHeight,colOffset,rowOffset)%% Align individual images to a standard image.%% 7/26/97  dhb       Wrote it.% 7/31/97  dhb, eah  Multiscale version, no extraction.% 8/13/97  dhb, eah  Save alignment matrices.% 10/15/97 dhb, eah  Set alignIters according to size.%                    Made it a function.% 10/21/97 dhb       Get edges first.% 10/23/97 dhb, eah, jmk  Call estAffineMultiEdge2.% 02/00/00 pxl       Changed parameters and stuff for new versionif (nargin <9)  type = 'int16';  originalPlatform = 0;  rawImageRoot = '';endalignImageRoot = rawImageRoot;% Set flags%rawImageDir = 'DC-FF';%rawImageRoot = 'orang';%alignImageDir = 'ALIGN_SUB';%alignImageRoot = 'expir2';nAlign = 31;refWl = 550;baseWl = 400;deltaWl = 10;% KernalsdxKernal = [-1 2 -1];dyKernal = dxKernal';energySize = 3;energyKernal = 1/(energySize^2)*ones(energySize,energySize);energyConstant = 5;edgeThresh = 0;% Image sizes%width = 2030;%height = 2042;%useWidth = 512;%useHeight = 512;%alignRowOffset = 5;%alignColOffset = 233;% Set the alginment iterations control for% commonly used sizes.  The leading zeros skip% the fine resolutions and keep us from running% out of memory.  Alignment image region is% assumed square here.if (useWidth >= 1024 & useWidth < 2048)  alignIters = [0 0 0 4 3 3];elseif (useWidth >= 512 & useWidth < 1024)  alignIters = [0 0 4 3 3];elseif (useWidth >= 256 & useWidth < 512)  alignIters = [0 4 3 3];elseif (useWidth >= 128 & useWidth < 256)  alignIters = [4 3 3];elseif (useWidth >= 64 & useWidth < 128)  alignIters = [4 3 3];elseif (useWidth >= 32 & useWidth < 64)  alignIters = [4 3 3];else  error('Need to set variables alignIters for image size');end% Change to raw image directoryprevDir = pwd;% Read in the reference imageif (exist('rawRefImage') ~= 1)  fprintf(1,'Read reference image (%g nm)\n',refWl);  eval(['cd(''' rawImageDir ''');']);  refImage  = SimReadRawImage([rawImageRoot num2str(refWl)],width,height,type,originalPlatform);  eval(['cd(''' prevDir ''');']);  refImage = refImage(alignRowOffset:alignRowOffset+useHeight-1,alignColOffset:alignColOffset+useWidth-1);  refImageMax = max(refImage(:));end% Loop over all the images and align each oneMaligns = zeros(3,3,nAlign);for i = 1:nAlign  fprintf(1,'Read %g nm image\n',baseWl+(i-1)*deltaWl);  eval(['cd(''' rawImageDir ''');']);  testImage = SimReadRawImage([rawImageRoot num2str(baseWl+(i-1)*deltaWl)],width,height,type,originalPlatform);  eval(['cd(''' prevDir ''');']);  testImage = testImage(alignRowOffset:alignRowOffset+useHeight-1,alignColOffset:alignColOffset+useWidth-1);  testImageMax = max(testImage(:));  % Find best alignment  fprintf(1,'Find edge based transformation\n');  Malign = ...      estAffineMultiEdge2(refImage,refImageMax*testImage/testImageMax,alignIters,eye(3,3),...        dxKernal,dyKernal,energyKernal,energyConstant,edgeThresh);  Maligns(:,:,i) = Malign;  % Align  fprintf(1,'Warp the image\n');  alignedImage = warpAffine2(testImage,Malign);  clear testImage  % Write out the image  fprintf(1,'Write the image\n');  eval(['cd(''' alignImageDir ''');']);  SimWriteRawImage([alignImageRoot num2str(baseWl+(i-1)*deltaWl)],alignedImage,type,originalPlatform);    eval(['cd(''' prevDir ''');']);  clear alignedImageend% Save the alignment matriceseval(['cd(''' alignImageDir ''');']);save Maligns Maligns alignRowOffset alignColOffseteval(['cd(''' prevDir ''');']);