function [outputImage] = SimSimulateCamera(inputImage,cameraOut,cameraDistance,exposureTime,fStop,offsetX,offsetY)% [outputImage] =%   SimSimulateCamera(inputImage,cameraOut,cameraDistance,exposureTime,fStop,[offsetX,offsetY])%% Scale and sum up hyperspectral images to produce % image according to the camera described in cameraOut.%% Input is a hyperspectral image in SimImageFile format% and cameraOut a camera description.% cameraDistance is the distance from the simulated camera to the scene.% offsetX and offsetY are the coordinates of the upleft corner% (in the hyperspectral data) where the simulated image will% be computed (default to (1,1))%% [NOTE: 4/22/04.  As far as I can tell, the camera file provided for the% input image plays no role in this routine, so that the code that should% handle the angular resolution shift between input and output camera % won't do anything at all.  This strikes me as fundamentally incorrect.% However, I can't delve into it today.]%% 06/12/98   pxl  Wrote it from MakeXYZ.% 06/22/98   pxl  Wrote an outside SimimageFile reading function.% 08/03/98   pxl  Test if arg1 is a structure or a filename.% 10/30/98   dhb  Added comments.%            dhb  Changed order of some steps to clarify code.% 10/31/98   pxl  Added parameters for distance and exposureTime% 11/22/98   pxl  Changed functions calls to follow custom camera files.% 12/8/98    dhb  Clean up.% 12/29/98   dhb  Make passed f-stop mandatory.% 12/31/98   dhb  Move setting of image type to mosaic'd into SimMosaic.% 2/24/99    dhb  Add mosaic flag, set type as sensor image.% 11/19/99   pxl  Add offsets for alignement with real images% 06/23/00   pxl  Added option for -1 cameraDistance which will simulate%                 using the same distance as the hyperspectral image was%                 taken.  % Check arguments.if (nargin < 5)	error(['Usage: outputImage = SimSimulateCamera(inputImage,cameraOut,distance,exposureTime,fStop,[offsetX, offsetY])']);endif (nargin < 7)  offsetX = 0;  offsetY = 0;end% Read the input hyperspectral imageif (~isstruct(inputImage))  inputImage = SimReadImage(inputImage); end% Read the camera description in the file or in the input variableif (~isstruct(cameraOut))  camera = SimReadCamera(cameraOut);else  camera = cameraOut;end% The steps executed here are described in the camera file% See the file camera.tpl for more information% As a reminder, a basic CCD camera will go through % the following steps :%   Compute the full resolution, un-mosaiced image%   Blur it%   Downsample it according to the camera description%     and the distance of simulation%   Add noise according to the model%   Mosaic the image outputImage = inputImage;outputImage.cameraFile = cameraOut;outputImage.mosaiced = 0; if (cameraDistance>0)    outputImage.cameraDistance = cameraDistance;else    outputImage.cameraDistance = inputImage.inputCameraDistance;end outputImage.exposureTime = exposureTime;outputImage.fStop = fStop;outputImage.offsetX = offsetX;outputImage.offsetY = offsetY;for (l=1:camera.numberAlgorithms)    %(dpl)commented out, don't need to see this line    %fprintf('\t\tCalling algorithm %s\n',camera.algorithms{l});    eval(['outputImage = ' camera.algorithms{l} '(outputImage,camera);']);end% This is set so that when the simulation is done, the% camera type matches what is in the image.  The% individual routines don't do this because at any% given stage, the simulation is only partially complete.% We also declare this a sensor image, so that we know it% is with respect to the camera.  Finally, we remove% information about the raw spectral images that we don't% need anymore.outputImage.imageType = 'sensor';if (isfield(outputImage,'rawImageDir'))	outputImage = rmfield(outputImage,'rawImageDir');endif (isfield(outputImage,'imageRoot'))	outputImage = rmfield(outputImage,'imageRoot');endif (isfield(outputImage,'imageFactors'))	outputImage = rmfield(outputImage,'imageFactors');endif (isfield(outputImage,'wavelengthSampling'))	outputImage = rmfield(outputImage,'wavelengthSampling');endif (isfield(outputImage,'inputCameraDistance'))	outputImage = rmfield(outputImage,'inputCameraDistance');end