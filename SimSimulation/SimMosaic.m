function [outputImage] = SimMosaic(inputImage,outputCamera)% [outputImage] = SimMosaic(inputImage,outputCamera)%% Simulates mosaic sampling, using the specified camera's% sampling pattern.%% The input image should be non-mosaiced image planes corresponding% to the same camera.%% 7/07/98   pxl  Wrote it.% 10/30/98  dhb  Tidying.% 11/21/98  pxl  Allowed passing of a structure.% 12/31/98  dhb  Set image type here.% 2/24/99   dhb  Don't set image type, but set mosaiced flag.%						dhb  Only allow image input.%           dhb  Allow passing structure or filename%           dhb  Separate input from output.% 3/10/99   dhb  Don't do anything for non-mosaiced cameras.% Copyright (c) 1999 David Brainard and Philippe Longere.   All rights reserved.% Read if necessaryif (~isstruct(inputImage))    inputImage = SimReadImage(inputImage);endif (~isstruct(outputCamera))    outputCamera = SimReadCamera(outputCamera);endoutputImage = inputImage; clear inputImage% Set images for use.images = outputImage.images;height = size(images,1);width = size(images,2);% If the mask has height = 1 and width = 1, then the camera% is not a mosaiced design and we do nothing.if (outputCamera.spatialLayout.dims(1) ~= 1 | outputCamera.spatialLayout.dims(1) ~= 1)        % The basic coding strategy is to multiply each non-mosaiced    % plane by a mask, which zeros the pixels that are    % not physically present in the camera for that    % sensor type.        % To save memory, there are two ways to do the multiplication...    % If the image is small, we do it in one piece.    if ((width<1000) & (height<1000))        mask = SimCreateMask(outputCamera,height,width);        images = images .* mask;                % If the image is big, we save memory by doing        % it in smaller chunks.    else        % Build the masks        dim2 = outputCamera.spatialLayout.dims(2);        mask = SimCreateMask(outputCamera,height,dim2);                % Do the multiply        for (k=0:fix(width/dim2)-1)            l = k*dim2;            images(:,l+1:l+dim2,:) = images(:,l+1:l+dim2,:) .* mask;        end                % If the array width is not a multiple of is not a multiple        % of the pattern width, there is a little step more to do        if (~isequal(mod(width,dim2),0))            mask = mask(:,1:mod(width,outputCamera.spatialLayout.dims(2)),:);            images(:,fix(width/dim2)*dim2+1:width,:) = ...                images(:,fix(width/dim2)*dim2+1:width,:) .* mask;        end    end        % Put back images and set mosaiced flag.    outputImage.images = images;    outputImage.mosaiced = 1;end