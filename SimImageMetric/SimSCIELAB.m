function errorImage = SimSCIELAB(image1,image2,whiteXYZ)% errorImage = SimSCIELAB(image1,image2,white)%% Compute the S-CIELAB error between two images.%% The images and passed white point must be in XYZ.% % The heart of the calculation and actual code is taken from% Mei Zhang's SCIELAB implementation, version 1-1-1.  I then% simplified it and converted it to use the simulator and psychtoolbox% color transformation routines.  I also made some simplifying% assumptions.  The image will always be two dimensional,% expressed as a 3-D matlab matrix.%% This code was verified against scielab.m, version 1.1.1, for% the case of 2-degree xyz input, standard CIELAB computation.%% 11/09/98  dhb  Wrote it.% 12/8/98   dhb  Changed the name.% 12/18/98  dhb  Brought in Mei's code, simplified for our purposes.% 03/29/00  pxl  Made it silent.  % Copyright (c) 1999 David Brainard and Philippe Longere.   All rights reserved.% Compute samples per degree from image1.if (~isstruct(image1.cameraFile))	camera = SimReadCamera(image1.cameraFile);else	camera = image1.cameraFile;endxResolution = camera.angularResolution.x;yResolution = camera.angularResolution.y;samplesPerDeg = (xResolution + yResolution)/2;% If not provided, estimate the white point as twice% the mean of image1.  This is probably as sensible as% anything else.if (nargin < 3)	whiteXYZ = squeeze(mean(mean(image1.images,1),2));end% Color transformation%fprintf('SimSCIELAB: Loading opponent data\n');S_use = [camera.wavelengthSampling.start camera.wavelengthSampling.step camera.wavelengthSampling.numberSamples];T_in = camera.spectralSensitivity;load T_PoirsonWandell;T_opp = SplineCmf(S_PoirsonWandell,T_PoirsonWandell,S_use);M = M_TToT(T_in,T_opp);% Convert XYZ or LMS representation to Poirson&Wandell opponent% representation.%fprintf('SimSCIELAB: Performing color transformations\n');opp1 = SimApplyColorTransform(M,image1.images);opp2 = SimApplyColorTransform(M,image2.images);% Prepare filters%fprintf('SimSCIELAB: Preparing filters\n');[k1, k2, k3] = separableFilters(samplesPerDeg, 3);% Apply the filters k1, k2, k3 to the images.% The edges of the images are reflected for convolution.w1 = opp1(:,:,1);w2 = opp1(:,:,2);w3 = opp1(:,:,3);wsize = size(w1);%fprintf('SimSCIELAB: Filtering BW plane of image1\n');p1 = separableConv(w1, k1, abs(k1));%fprintf('SimSCIELAB: Filtering RG plane of image1\n');p2 = separableConv(w2, k2, abs(k2));%fprintf('SimSCIELAB: Filtering BY plane of image1\n');p3 = separableConv(w3, k3, abs(k3));new1 = opp1;new1(:,:,1) = p1;new1(:,:,2) = p2;new1(:,:,3) = p3;clear opp1;w1 = opp2(:,:,1);w2 = opp2(:,:,2);w3 = opp2(:,:,3);wsize = size(w1);%fprintf('SimSCIELAB: Filtering BW plane of image2\n');p1 = separableConv(w1, k1, abs(k1));%fprintf('SimSCIELAB: Filtering RG plane of image2\n');p2 = separableConv(w2, k2, abs(k2));%fprintf('SimSCIELAB: Filtering BY plane of image2\n');p3 = separableConv(w3, k3, abs(k3));new2 = opp2;new2(:,:,1) = p1;new2(:,:,2) = p2;new2(:,:,3) = p3;clear opp2;clear p1 p2 p3 w1 w2 w3 k1 k2 k3;% Convert back to XYZ and compute error metric.%fprintf('SimSCIELAB: Computing CIELAB differences\n');result1 = SimApplyColorTransform(inv(M),new1);result2 = SimApplyColorTransform(inv(M),new2);errorImage = SimComputeDeltaELab(result1,result2,whiteXYZ);