% TestDemosaic%% Script to compare demosaicing algoriths for different mosaic.% It starts with a hyperspectral image and computes an ideal% image without sampling.  It then computes a mosaic'd image% for a specified mosaic.  You can put in whatever mosaic% you like.  It demosaics with three algorithms:% quick, bilinear, and bayesian.  It then uses SCIELAB% to compute how good the demosaic'd images are.%% 11/6/98  dhb, pxl  Wrote it.% 11/9/98  dhb       Modified to twiddle camera description.% 12/8/98  dhb       Distance in meters now.% 12/9/98  dhb       Got it all working, added comments.% 12/18/98 dhb       Render pictures for monitors rather than just raw.%          dhb       Adjust spatial resolution before CIELAB calcs.% 1/18/99  dhb       Make it work with various new conventions.% 4/19/99  dhb       Replace SimGriddataInterp with SimFastLinearInterp.%					 dhb			 Time interpolations and report.% 4/21/99  dhb       Can work without Bayesian code present.% 4/23/99  dhb       Remove quick algorithm and replace with Freeman algorithm.% 2/10/07  dhb       Update to make sure it works with PTB-3.% Copyright (c) 1999 David Brainard and Philippe Longere.   All rights reserved.% Clear outclear allclose all% ParametersbilinearFast = 1;% Define subset of image for case where we% are running on a slow machine or one% without much memory.SLOW_COMPUTER = 0;slowWidth = 64;slowHeight = 64;% Decide whether Bayesian method is available.if (exist('SimBayesInterp') == 2)	DO_BAYES = 1;else	DO_BAYES = 0;end% Define names.  Need to be careful to define% a reasonable camera for each image, otherwise% the resampling can produce strange looking % results.imageKey = 'bfgg';switch (imageKey)	case 'bfgg'		theImageName = 'BFGG_128';		theIllumName = 'BFGG';		theCameraName = 'kodakdcs200_50mm';		cameraDistance = 3;		exposureDuration = 0.5;		fStop = 5.6;	case 'bfgb',		theImageName = 'BFGB_128';		theIllumName = 'BFGB';		theCameraName =  'kodakdcs200_50mm';		cameraDistance = 3;		exposureDuration = 0.5;		fStop = 5.6;end% Define monitortheMonitorName = 'SimToolboxTest';% Define paths to find data[imagesRootDir,dirSep] = SimDefineImagePath;inputImageFile = [imagesRootDir theImageName dirSep theImageName '.Simg'];theCameraFile = [theCameraName '.Scam'];theMonitorFile = [theMonitorName '.Smon'];% Read the camera, then modify the mosaic pattern% to whatever we like.  This allows us to test different% patterns without making a lot of camera files.theRawCamera = SimReadCamera(theCameraFile);theMosaicCamera = theRawCamera;mosaicPattern = 'bayer';switch (mosaicPattern)	case 'bayer',		theMosaicCamera.spatialLayout.mosaic = ...			[ ...			1 2 ; ...			2 3 ; ...			];	case 'chevron',		theMosaicCamera.spatialLayout.mosaic = ...			[ ...			1 3 2 3 ; ...			2 1 3 1 ; ...			3 2 1 2 ; ...			];	case 'stripes',		theMosaicCamera.spatialLayout.mosaic = ...			[ ...			1 2 3 ; ...			1 2 3 ; ...			];	otherwise,		theMosaicCamera.spatialLayout.mosaic = ...			[ ...			1 2 ; ...			2 3 ; ...			];end[patternRows,patternCols] = size(theMosaicCamera.spatialLayout.mosaic);theMosaicCamera.spatialLayout.dims = [patternRows patternCols 1]';if (SLOW_COMPUTER)	theMosaicCamera.width = slowWidth;	theMosaicCamera.height = slowHeight;end% Create a non-mosaiced camera with same properties otherwise.theIdealCamera = theRawCamera;theIdealCamera.spatialLayout.mosaic = zeros(1,1,3);theIdealCamera.spatialLayout.mosaic(:,:,1) = 1;theIdealCamera.spatialLayout.mosaic(:,:,2) = 2;theIdealCamera.spatialLayout.mosaic(:,:,3) = 3;theIdealCamera.spatialLayout.dims = [1 1 3];if (SLOW_COMPUTER)	theIdealCamera.width = slowWidth;	theIdealCamera.height = slowHeight;end% Simulate the mosaiced and ideal camera output.mosaicImage = SimSimulateCamera(inputImageFile,theMosaicCamera,cameraDistance,exposureDuration,fStop);idealImage = SimSimulateCamera(inputImageFile,theIdealCamera,cameraDistance,exposureDuration,fStop);% Show the ideal imagefigure(1); clf;subplot(2,3,2);[scaleImage,minScale,maxScale] = SimScale(idealImage.images);imshow(scaleImage);title('Ideal');drawnow;% Freeman demosaicingt0 = clock;medFilterSize = 5;freemanImage = SimFreemanInterp(mosaicImage,medFilterSize);freemanTime = etime(clock,t0);subplot(2,3,4);imshow(Trunc(SimScale(freemanImage.images,minScale,maxScale)));title('Freeman');drawnow;% Bilinear demosaicingt0 = clock;if (bilinearFast)	bilinearImage = SimFastLinearInterp(mosaicImage);else	bilinearImage = SimGriddataInterp(mosaicImage);endbilinearTime = etime(clock,t0);subplot(2,3,5);imshow(Trunc(SimScale(bilinearImage.images,minScale,maxScale)));title('Bilinear');drawnow;% Bayesian demosaicingif (DO_BAYES)	nConvPixels = 5;	noiseFrac = 0.05;	PSVars = 1;	bilinBootstrap = 1;	t0 = clock;	bayesImage = SimBayesInterp(mosaicImage,nConvPixels,noiseFrac,PSVars,bilinBootstrap);	bayesTime = etime(clock,t0);	subplot(2,3,6);	imshow(Trunc(SimScale(bayesImage.images,minScale,maxScale)));	title('Bayesian');	drawnow;end% Color balance the images to XYZ in preparation for S-CIELAB calculations.% By default, SimBalancing takes us into CIE XYZ scaled for cd/m2.load spd_D65Render;eval(['load spd_' theIllumName]);eval(['theIllumSpd = spd_' theIllumName ';']);eval(['theIllumS = S_' theIllumName ';']);load T_xyz1931T_render = 683*T_xyz1931;whiteXYZ = T_render*spd_D65Render;idealRender = SimBalancing(idealImage,[380 5 81],theIllumSpd,[380 5 81],spd_D65Render);idealMonitor = SimRenderOnMonitor(idealRender,theMonitorFile,1);freemanRender = SimBalancing(freemanImage,[380 5 81],theIllumSpd,[380 5 81],spd_D65Render);freemanMonitor = SimRenderOnMonitor(freemanRender,theMonitorFile,1);bilinearRender = SimBalancing(bilinearImage,[380 5 81],theIllumSpd,[380 5 81],spd_D65Render);bilinearMonitor = SimRenderOnMonitor(bilinearRender,theMonitorFile,1);if (DO_BAYES)	bayesRender = SimBalancing(bayesImage,[380 5 81],theIllumSpd,[380 5 81],spd_D65Render);	bayesMonitor = SimRenderOnMonitor(bayesRender,theMonitorFile,1);endfigure(2); clf;subplot(2,3,2);[scaleImage,minScale,maxScale] = SimScale(idealMonitor.images);imshow(scaleImage);title('Ideal');drawnow;subplot(2,3,4);imshow(Trunc(SimScale(freemanMonitor.images,minScale,maxScale)));title('Freeman');subplot(2,3,5);imshow(Trunc(SimScale(bilinearMonitor.images,minScale,maxScale)));title('Bilinear');drawnow;if (DO_BAYES)	subplot(2,3,6);	imshow(Trunc(SimScale(bayesMonitor.images,minScale,maxScale)));	title('Bayesian');	drawnow;end% Compute SCIELAB error.  To make the calculation realistic,% we fudge the angular resolution to make it more like what% you'd expect when inspecting closely on a monitor.  Note% that the relative quality returned for these images is% quite dependent on this.resolutionFactor = 10;idealRender.cameraFile.angularResolution.x = ...	idealRender.cameraFile.angularResolution.x/resolutionFactor;idealRender.cameraFile.angularResolution.y = ...	idealRender.cameraFile.angularResolution.y/resolutionFactor;freemanRender.cameraFile.angularResolution.x = ...	freemanRender.cameraFile.angularResolution.x/resolutionFactor;freemanRender.cameraFile.angularResolution.y = ...	freemanRender.cameraFile.angularResolution.y/resolutionFactor;bilinearRender.cameraFile.angularResolution.x = ...	bilinearRender.cameraFile.angularResolution.x/resolutionFactor;bilinearRender.cameraFile.angularResolution.y = ...	bilinearRender.cameraFile.angularResolution.y/resolutionFactor;if (DO_BAYES)	bayesRender.cameraFile.angularResolution.x = ...		bayesRender.cameraFile.angularResolution.x/resolutionFactor;	bayesRender.cameraFile.angularResolution.y = ...		bayesRender.cameraFile.angularResolution.y/resolutionFactor;endfreemanError = SimSCIELAB(idealRender,freemanRender,whiteXYZ);bilinearError = SimSCIELAB(idealRender,bilinearRender,whiteXYZ);if (DO_BAYES)	bayesError = SimSCIELAB(idealRender,bayesRender,whiteXYZ);endborder = 5;[n,m] = size(freemanError);maxErr = max(max([freemanError(border:m-border,border:n-border) ...								  bilinearError(border:m-border,border:n-border) ...								  bayesError(border:m-border,border:n-border)]));figure(3); clf;subplot(1,3,1);imshow(freemanError(border:m-border,border:n-border)/maxErr);title('Freeman SCIELAB');subplot(1,3,2);imshow(bilinearError(border:m-border,border:n-border)/maxErr);title('Bilinear SCIELAB');if (DO_BAYES)	subplot(1,3,3);	imshow(bayesError(border:m-border,border:n-border)/maxErr);	title('Bayesian SCIELAB');	drawnow;end% Compute mean, max DE errorfreemanMeanDE = mean(mean(freemanError(border:m-border,border:n-border)));freemanMaxDE = max(max(freemanError(border:m-border,border:n-border)));bilinearMeanDE = mean(mean(bilinearError(border:m-border,border:n-border)));bilinearMaxDE = max(max(bilinearError(border:m-border,border:n-border)));if (DO_BAYES)	bayesMeanDE = mean(mean(bayesError(border:m-border,border:n-border)));	bayesMaxDE = max(max(bayesError(border:m-border,border:n-border)));endif (DO_BAYES)	fprintf('Mean DE errors: freeman %g; biliner %g; bayes %g\n',...		freemanMeanDE,bilinearMeanDE,bayesMeanDE);	fprintf('Max DE errors: freeman %g; biliner %g; bayes %g\n',...		freemanMaxDE,bilinearMaxDE,bayesMaxDE);	fprintf('Time in seconds, freeman: %g, bilinear: %g, bayes: %g\n', ...		freemanTime,bilinearTime,bayesTime);else	fprintf('Mean DE errors: freeman %g; biliner %g\n',...		freemanMeanDE,bilinearMeanDE);	fprintf('Max DE errors: freeman %g; biliner %g\n',...		freemanMaxDE,bilinearMaxDE);	fprintf('Time in seconds, freeman: %g, bilinear: %g\n', ...		freemanTime,bilinearTime);end