% TestColorCorrect%% Run various color correction algorithms on a simulated% image where illuminant is known (more or less).%% An image is simulated for human sensors and also for a% camera.  Various color balancing methods are compared.%% Bayesian and Subspace methods run without crashing but% are not carefully debugged.  For the one test case here,% the Bayes method gives a reasonable result.  Have not% tried subspace or Finlayson in recent memory (5/18/12, dhb).%% 4/16/99  dhb  Wrote it.% 4/23/99  dhb  Add slow computer flag.% 6/26/02  dhb  Add prior type.% 2/10/07  dhb  Got this updated.% 5/18/12  dhb  Made sure it runs and add Bayes illum to plot.% Copyright (c) 1999 David Brainard and Philippe Longere.   All rights reserved.% Clear outclearclose all% Operation flagsDISPLAY_IMAGES = 1;ILLUM_PLOTS = 1;STEP_PAUSE = 0;% SLOW_COMPUTER flag.  Set this to 1% if you're running on a slow machine.% It's effect is simply to decrease the% resolution of the simulated image.SLOW_COMPUTER = 0;% Algorithm choice flags.% Currently FINLAYSON code does not run.DO_BAYESIAN = 1;DO_SUBSPACE = 1;DO_FINLAYSON = 0;% Render under true illuminant or D65.% (Affects illuminant based rendering only.)RENDER_TRUE = 1;% Define some names.theIllumName = 'cacaphony';theCameraName = 'kodakdcs200_50mm';theMonitorName = 'SimToolboxTest';hyperImageName = 'Cacaphony290';colorPriorsName = 'cieday8munsell8ColorPriors';% Use camera sensors or generate Guassian ones.% If generate, specify number and sensor sd.% Sensors will be evenly spaced through the% spectrum.GENERATE_SENSORS = 0;numberSensors = 5;sensorSd = 66;% Define number of methodsnMethods = 5;if (DO_BAYESIAN)	nMethods = nMethods+1;endif (DO_SUBSPACE)	nMethods = nMethods+1;endif (DO_FINLAYSON)	nMethods = nMethods+1;endwhichPanel = 1;plotHeight = ceil(nMethods/2);% Set some simulation parameters.  % We don't actually know what the% exposure time was for the DCS image,% so this is estimated by comparing the% maximum values in the image to what% we predict from the sensor responses% to the measured illuminant.if (SLOW_COMPUTER)	cameraDistance = 20;else	cameraDistance = 3.32;endexposureDuration = 0.1;fStop = 11;% Define paths to find data.  If you create a new% folder with a unique name and put it on MATLAB's% path, then you can replace SimDefineImagePath% below with SimDefineImagePath(yourFolderName)% and things should work tranparently.[imagesRootDir,dirSep] = SimDefineImagePath;hyperImageFile = [imagesRootDir hyperImageName dirSep hyperImageName '.Simg'];theCameraFile = [theCameraName '.Scam'];theMonitorFile = [theMonitorName '.Smon'];% Load known illuminant and color matching functionseval(['load spd_' theIllumName]);eval(['theIllumSpd = spd_' theIllumName ';']);eval(['theIllumS = S_' theIllumName ';']);load T_xyz1931;% 7/16/24. This routine assumed that T_xyz1931 is on [380 5 81] wavelength% sampling but that changed in PTB at some point.  Forcing it% back here.  DHBT_xyz1931 = SplineCmf(S_xyz1931,T_xyz1931,theIllumS);S_xyz1931 = theIllumS;T_xyz1931 = 683*T_xyz1931;illumXYZ = T_xyz1931*theIllumSpd;renderFactor = 35/illumXYZ(2);T_render = T_xyz1931;if (RENDER_TRUE)	S_render = S_xyz1931;	spd_render = theIllumSpd*renderFactor;else	load spd_D65Render	spd_render = spd_D65Render;	S_render = S_D65Render;end% Read the camera and create a non-mosaiced camera.% If GENERATE SENSORS is set, generate the% specified number of Gaussian sensors and put these% into the camera.  It is  important to make sure that% the total sensitivity of the new sensors is reasonable,% otherwise the simulated image will come out all black% or all white.theCamera = SimReadCamera(theCameraFile);if (GENERATE_SENSORS)	cameraS = [theCamera.wavelengthSampling.start ...					   theCamera.wavelengthSampling.step ...	           theCamera.wavelengthSampling.numberSamples];	cameraWls = SToWls(cameraS);	minWl = min(cameraWls); maxWl = max(cameraWls);	wlRange = maxWl-minWl;	sensorPeakSteps = wlRange/(numberSensors);	sensorPeaks = (minWl+sensorPeakSteps/2:sensorPeakSteps:minWl+(numberSensors-1+0.5)*sensorPeakSteps)';	sensorSds = sensorSd*ones(numberSensors,1);	theCamera.numberSensors = numberSensors;	gaussianSensors = SimMakeGaussianSensors([sensorPeaks sensorSds],cameraS);	oldSensitivity = mean(sum(theCamera.spectralSensitivity));	newSensitivity = mean(sum(gaussianSensors));	theCamera.spectralSensitivity = (oldSensitivity/newSensitivity)*gaussianSensors;else	numberSensors = theCamera.numberSensors;endtheCamera.spatialLayout.mosaic = zeros(1,1,numberSensors);for i1 = 1:numberSensors	theCamera.spatialLayout.mosaic(:,:,i1) = i1;endtheCamera.spatialLayout.dims = [1 1 numberSensors];% Read the camera and create a non-mosaiced camera with% the three sensors matched to human vision.  Useful% for generating a true rendering.humanCamera = SimReadCamera(theCameraFile);cameraS = [humanCamera.wavelengthSampling.start ...      humanCamera.wavelengthSampling.step ...      humanCamera.wavelengthSampling.numberSamples];humanCamera.numberSensors = 3;humanSensors = SplineCmf(S_xyz1931,T_xyz1931,cameraS);oldSensitivity = mean(sum(humanCamera.spectralSensitivity));newSensitivity = mean(sum(humanSensors));humanCamera.spectralSensitivity = (oldSensitivity/newSensitivity)*humanSensors;humanCamera.spatialLayout.mosaic = zeros(1,1,numberSensors);for i1 = 1:numberSensors  humanCamera.spatialLayout.mosaic(:,:,i1) = i1;endhumanCamera.spatialLayout.dims = [1 1 numberSensors];% Simulate the images from hyperspectral datasimulatedImage = SimSimulateCamera(hyperImageFile,theCamera,cameraDistance,exposureDuration,fStop);humanImage =  SimSimulateCamera(hyperImageFile,humanCamera,cameraDistance,exposureDuration,fStop);% Load color priors, then adjust for the number of sensors.colorPriors = SimLoadColorPriors(colorPriorsName);if (numberSensors > size(colorPriors.light.B,2))	error('Not enough dimension in illuminant prior');endif (numberSensors > size(colorPriors.sur.B,2))	error('Not enough dimension in surface prior');endcolorPriors.light.B = colorPriors.light.B(:,1:numberSensors);colorPriors.sur.B = colorPriors.sur.B(:,1:numberSensors);colorPriors.light.u = colorPriors.light.u(1:numberSensors);colorPriors.sur.u = colorPriors.sur.u(1:numberSensors);colorPriors.light.K = colorPriors.light.K(1:numberSensors,1:numberSensors);colorPriors.sur.K = colorPriors.sur.K(1:numberSensors,1:numberSensors);% Color balancing -- render human sensors to monitorfprintf('Balance human direct\n');simMonitorImage = SimRenderOnMonitor(humanImage,theMonitorFile,-1);if (DISPLAY_IMAGES)	figure(1);	subplot(plotHeight,2,whichPanel); whichPanel = whichPanel+1;	imshow(Trunc(SimScale(simMonitorImage.images)));	title('Human Direct');	drawnow;endif (STEP_PAUSE)	pauseend% Color balancing -- just show camera RGB onto monitor RGBif (DISPLAY_IMAGES)	figure(1);	subplot(plotHeight,2,whichPanel); whichPanel = whichPanel+1;	imshow(Trunc(SimScale(simulatedImage.images(:,:,1:3))));	title('Camera RGB -> Monitor RGB');	drawnow;endif (STEP_PAUSE)	pauseend% Color balancing -- render camera sensors to monitorfprintf('Balance camera direct\n');simMonitorImage = SimRenderOnMonitor(simulatedImage,theMonitorFile,-1);if (DISPLAY_IMAGES)	figure(1);	subplot(plotHeight,2,whichPanel); whichPanel = whichPanel+1;	imshow(Trunc(SimScale(simMonitorImage.images)));	title('Camera Direct');	drawnow;endif (STEP_PAUSE)	pauseend% Color balancing -- known illuminantfprintf('Balance with known illuminant\n');simKnownImage = simulatedImage;simKnownImage.estimatedIlluminant.spd = theIllumSpd;simKnownImage.estimatedIlluminant.S = theIllumS;simRenderedImage = SimBalancing(simKnownImage,...	simKnownImage.estimatedIlluminant.S,simKnownImage.estimatedIlluminant.spd,...	S_render,spd_render,S_render,T_render,colorPriors.S,colorPriors.sur.B);simMonitorImage = SimRenderOnMonitor(simRenderedImage,theMonitorFile,-1);if (DISPLAY_IMAGES)	figure(1);	subplot(plotHeight,2,whichPanel); whichPanel = whichPanel+1;	imshow(Trunc(SimScale(simMonitorImage.images)));	title('Known Illuminant');	drawnow;endif (STEP_PAUSE)	pauseend% Find best representation of known illuminant within% color prior.  Set the illuminant prior to be this% illuminant.  This is not something we'd do in real% color correction, but is helpful in testing that% the algorithms function more or less correctly.temp = SplineSpd(theIllumS,theIllumSpd,colorPriors.S);image_u_light = SimFindPosIllum(temp,colorPriors.light.B);factor = colorPriors.light.u\image_u_light;theIllumBasisSpd = colorPriors.light.B*image_u_light;colorPriors.light.u = image_u_light;colorPriors.light.K = (factor.^2)*colorPriors.light.K;colorPriors.light.priorType = 'truncNormalWeights';% Find surface reflectances within surface linear model and with% respect to the known illuminant.  To make gray world work,% we use the known illuminant within the illuminant linear model,% not the actual known illuminant.rawSurfaceImage = SimFindSurfaceRefl(simKnownImage,theIllumS,theIllumBasisSpd, ...	colorPriors.S,colorPriors.sur.B);image_u_surface = squeeze(mean(mean(rawSurfaceImage,1),2));factor = colorPriors.sur.u\image_u_surface;colorPriors.sur.u = image_u_surface;colorPriors.sur.K = (factor.^2)*colorPriors.sur.K;colorPriorss.surPriorType = 'truncNormalWeights';% Color balancing - gray worldfprintf('Balance with gray world\n');SimGrayWorldImage = simulatedImage;SimGrayWorldImage = SimGrayWorldIllum(SimGrayWorldImage,colorPriors);simRenderedImage = SimBalancing(SimGrayWorldImage,...	SimGrayWorldImage.estimatedIlluminant.S,SimGrayWorldImage.estimatedIlluminant.spd,...	S_render,spd_render,S_render,T_render,colorPriors.S,colorPriors.sur.B);simMonitorImage = SimRenderOnMonitor(simRenderedImage,theMonitorFile,-1);if (DISPLAY_IMAGES)	figure(1);	subplot(plotHeight,2,whichPanel); whichPanel = whichPanel+1;	imshow(Trunc(SimScale(simMonitorImage.images)));	title('Gray World Estimate');	drawnow;endif (STEP_PAUSE)	pauseend% Make a plot of illuminants.  Red and green curves% overlap, since we tweaked the prior to make the gray world% algorithm work perfectly within its linear model universe.if (ILLUM_PLOTS)	figure(2); clf;	hold on	plot(SToWls(theIllumS),theIllumSpd,'k','LineWidth',2);	plot(SToWls(colorPriors.S),theIllumBasisSpd,'r','LineWidth',2);	plot(SToWls(SimGrayWorldImage.estimatedIlluminant.S),SimGrayWorldImage.estimatedIlluminant.spd,'g');	xlabel('Wavelength');	ylabel('Power');	title('Known (blk), linear model (red) and gray world (grn) illums');	drawnow;end% Color balancing - Bayesianif (DO_BAYESIAN)	fprintf('Balance with Bayesian\n');	N_beta = 8;	N_trials = 1;	GRAYWORLD_SCALES_MEAN = 0;	simBayesImage = simulatedImage;	simBayesImage = SimBayesIllum(simBayesImage,colorPriors,...	  N_beta,N_trials,GRAYWORLD_SCALES_MEAN);	simRenderedImage = SimBalancing(simBayesImage,...		simBayesImage.estimatedIlluminant.S,simBayesImage.estimatedIlluminant.spd,...		S_render,spd_render,S_render,T_render,colorPriors.S,colorPriors.sur.B);	simMonitorImage = SimRenderOnMonitor(simRenderedImage,theMonitorFile,-1);	if (DISPLAY_IMAGES)		figure(1);		subplot(plotHeight,2,whichPanel); whichPanel = whichPanel+1;		imshow(Trunc(SimScale(simMonitorImage.images)));		title('Bayesian Estimate');		drawnow;    end    if (ILLUM_PLOTS)        figure(2);         plot(SToWls(simBayesImage.estimatedIlluminant.S),simBayesImage.estimatedIlluminant.spd,'b');        xlabel('Wavelength');        ylabel('Power');        title('Known (blk), linear model (red), gray world (grn), bayes (blue) illums');        drawnow;    end	if (STEP_PAUSE)		pause	endend% Color balancing - Subspaceif (DO_SUBSPACE)	fprintf('Balance with subspace\n');	simSubspaceImage = simulatedImage;	simSubspaceImage = SimSubspaceIllum(simSubspaceImage,colorPriors);	simRenderedImage = SimBalancing(simSubspaceImage,...		simSubspaceImage.estimatedIlluminant.S,simSubspaceImage.estimatedIlluminant.spd,...		S_render,spd_render,S_render,T_render,colorPriors.S,colorPriors.sur.B);	simMonitorImage = SimRenderOnMonitor(simRenderedImage,theMonitorFile,-1);	if (DISPLAY_IMAGES)		figure(1);		subplot(plotHeight,2,whichPanel); whichPanel = whichPanel+1;		imshow(Trunc(SimScale(simMonitorImage.images)));		title('Subspace Estimate');		drawnow;	end	if (STEP_PAUSE)		pause	endend% Color balancing - Finlaysonif (DO_FINLAYSON)	fprintf('Balance with Finlayson\n');	simFinlaysonImage = simulatedImage;	simFinlaysonImage = SimFinlaysonIllum(simFinlaysonImage,colorPriors);	simRenderedImage = SimBalancing(simFinlaysonImage,...		simFinlaysonImage.estimatedIlluminant.S,simFinlaysonImage.estimatedIlluminant.spd,...		S_render,spd_render,S_render,T_render,colorPriors.S,colorPriors.sur.B);	simMonitorImage = SimRenderOnMonitor(simRenderedImage,theMonitorFile,-1);	if (DISPLAY_IMAGES)		figure(1);		subplot(plotHeight,2,whichPanel); whichPanel = whichPanel+1;		imshow(Trunc(SimScale(simMonitorImage.images)));		title('Finlayson Estimate');		drawnow;	end	if (STEP_PAUSE)		pause	endend