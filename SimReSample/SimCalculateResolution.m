function [useInputWidth,useInputHeight,useOutputWidth,useOutputHeight] = ...	SimCalculateResolution(inputImage,outputCamera)% [useInputWidth,useInputHeight,useOutputWidth,useOutputHeight] = ...%  	SimCalculateResolution(inputImage,outputCamera)%% Calculate the portion of the input image that is seen% by the camera, according to the viewing parameters.  Return% the size of the input image that should be mapped% onto the specified size of the simulated image.  All dimensions% returned are guaranteed to be less than or equal to what is% available.  It is possible that the full input image% will not fill the simulated image, given the camera resolution.% In this case, as much output as is available will be created.%% [NOTE: 4/22/04. I am not convinced that this code is well-debugged% for various combinations of input and output angular resolution.% It should be looked at carefully, in conjunction with SimSimulateCamera,% before the spatial aspects are relied on in any serious manner.  DHB.]%% 10/30/98  dhb  Added comments.%           dhb  Changed span to cameraDistance% 12/31/98  dhb  Allow structure as input camera file.%           dhb  Rewrite algorithm and return format.DEBUG_PRINT = 0;% Read the camera description for the input imageif (isstruct(inputImage.cameraFile))	inputCamera = inputImage.cameraFile;else	inputCamera = SimReadCamera(inputImage.cameraFile);end% Transform image information to numeric format.  This% only needs to be done if they are in string format.% Note that both input and output distances are stored% in the inputImage image.  (The input distance is the% distance to the original hyperspectral image.) outputCamera.angularResolution.x = ...	outputCamera.angularResolution.x;outputCamera.angularResolution.y = ...	outputCamera.angularResolution.y;inputCamera.angularResolution.x = ...	inputCamera.angularResolution.x;inputCamera.angularResolution.y = ...	inputCamera.angularResolution.y;inputImage.inputCameraDistance = ...	inputImage.inputCameraDistance;%%%%%%%%%%%%%%%% Former code% Compute the size in the world that we've got with the hyperspectral image.inputAngle.x = (pi/180)*inputImage.width/inputCamera.angularResolution.x;inputAngle.y = (pi/180)*inputImage.height/inputCamera.angularResolution.y;inputSize.x = 2*inputImage.inputCameraDistance*atan((inputAngle.x/2));inputSize.y = 2*inputImage.inputCameraDistance*atan((inputAngle.y/2));% Compute the size in the world that the simulated camera is looking at.outputAngle.x = (pi/180)*outputCamera.width/outputCamera.angularResolution.x;outputAngle.y = (pi/180)*outputCamera.height/outputCamera.angularResolution.y;outputSize.x = 2*inputImage.cameraDistance*atan((outputAngle.x/2));outputSize.y = 2*inputImage.cameraDistance*atan((outputAngle.y/2));if (DEBUG_PRINT)	fprintf('Input: x, %g, y %g\n',inputImage.width,inputImage.height);	fprintf('Ouput: x, %g, y %g\n',outputCamera.width,outputCamera.height);	fprintf('Input angular resolution: x, %g, y, %g\n',...		inputCamera.angularResolution.x,inputCamera.angularResolution.y);	fprintf('Output angular resolution: x, %g, y, %g\n',...		outputCamera.angularResolution.x,outputCamera.angularResolution.y);	fprintf('Input distance: %g\n',...		inputImage.inputCameraDistance);	fprintf('Output distance: %g\n',...		inputImage.cameraDistance);	fprintf('Input angle %g %g radians, %g %g degrees\n',...		inputAngle.x,inputAngle.y,(180/pi)*inputAngle.x,(180/pi)*inputAngle.y);	fprintf('Input size %g %g\n',inputSize.x,inputSize.y);	fprintf('Output angle %g %g radians, %g %g degrees\n',...		outputAngle.x,outputAngle.y,(180/pi)*outputAngle.x,(180/pi)*outputAngle.y);	fprintf('Output size %g %g\n',outputSize.x,outputSize.y);end% Figure out what fraction of the hyperspectral image we need% and what fraction of the simulated image we can fill.  If the% hyperspectral image is bigger than the simulated image, we use% the appropriate fraction and fill the whole simulated image.  If% the hyperspectral image is smaller, we use the whole thing and% only fill a fraction of the output image.useSize.x = min([inputSize.x outputSize.x]);useSize.y = min([inputSize.y outputSize.y]);useInputWidth = round((useSize.x/inputSize.x)*inputImage.width);useOutputWidth = round((useSize.x/outputSize.x)*outputCamera.width);useInputHeight = round((useSize.y/inputSize.y)*inputImage.height);useOutputHeight = round((useSize.y/outputSize.y)*outputCamera.height);%%%%%%%%%%%%%%% New ... pxl 03/06/00%%%%%%%%%%%%%%% Using formula no 2 in Longere/Brainard ChapteruseOutputWidth = min(outputCamera.width,round(180/pi*2*outputCamera.angularResolution.x*atan((inputImage.inputCameraDistance/inputImage.cameraDistance)*tan((pi/180)*inputImage.width/(2*inputCamera.angularResolution.x)))));useOutputHeight =  min(outputCamera.height,round(180/pi*2*outputCamera.angularResolution.y*atan((inputImage.inputCameraDistance/inputImage.cameraDistance)*tan((pi/180)*inputImage.width/(2*inputCamera.angularResolution.y)))));