function [outputImage,weights] = SimHyperBalancing(hyperImage,S_acquireSpd,spd_acquire,S_renderSpd,spd_render)% [outputImage] = SimHyperBalancing(inputImage,S_acquire,spd_acquire,S_renderSpd,spd_render)%% Balances hyperspectral data acquired under one illuminant% to data seen under another illuminant.  Basically divides% by spd_acquire and multiplies by spd_render.%% If the image data are on disk, this acts by adjusting the image% factors used to convert units to power on a later read.  If the% image data already are in power or quantal units, the actual% image data are adjusted.  I think this convention is OK, although% it makes me a little nervous.%% 5/13/04   dhb     Wrote it.% 5/17/04   dhb     Pare it down to bare essentials.% Spline spds to match hyperspectral data wavelength sampling, and compute% weights.spd_acquire = SplineSpd(S_acquireSpd,spd_acquire,hyperImage.wavelengthSampling);spd_render = SplineSpd(S_renderSpd,spd_render,hyperImage.wavelengthSampling);weights = spd_render./spd_acquire;% Initialize image structure.outputImage = hyperImage;switch (hyperImage.unit) case 'Disk',    outputImage.imageFactors = hyperImage.imageFactors .* weights; case 'Power', case 'Quanta',    outputImage.images = zeros(hyperImage.height,hyperImage.width,hyperImage.wavelengthSampling.numberSamples);    for l = 0:hyperImage.wavelengthSampling.numberSamples-1        outputImage.images(:,:,l+1) = hyperImage.images(:,:,l+1)*weights(l+1);    endend