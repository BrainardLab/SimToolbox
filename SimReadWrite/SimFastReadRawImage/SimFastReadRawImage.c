/* SimFastReadRawImage.cThis function speeds up the reading of raw files(up to ten times faster).If your system is able to compile MEX files(ie if you have a C compiler and if it is set up correctly for use within Matlab) you should compile it	mex SimFastReadRawImage.c 	Function SimReadRawImage will automatically usethe MEX file rather than the Matlab read function ifit can find it on the path.This function takes 5 arguments:  (1) the name of the file and its (2) width and (3) height.  The (4) type is the type data in the raw file (which is to be  given in MATLAB mode ie uchar, uint16 or uint32)   And (5) the byte-reverse flag, that deals with Motorola  and Intel difference of byte ordering (little or big endian)  As a reminder invert should be 1 if you change platform type  from writing (ie acquiring) to reading (ie running the Simulator).07/22/98  pxl  Wrote it  12/10/98  pxl  Taken type specification into account1/26/99   dhb  Use mxClassID type and constants from matrix.h.3/2/99    dhb  Need to update to make default int16, not uint16.               Need to understand int16, int32 types.*/#include "mex.h"#include <stdio.h>mxClassID GetClassID(char *type);void mexFunction(int nlhs, mxArray *plhs[],int nrhs, const mxArray *prhs[]){  FILE * file;  char *fileName;  int   buflen;  int   status;  int dims[2];  mxArray *array_ptr;  int ndim = 2;  int offset =0;  int i,j,k=0;  unsigned char *ptr,c;  int sizeInOctets=2,invert;  char str[256];  char *type;    mxClassID mxClass = -1;  if (nrhs < 3) {    mexErrMsgTxt("Not enough arguments ");}  buflen = (mxGetM(prhs[0])*mxGetN(prhs[0]))+1;  fileName = mxCalloc(buflen, sizeof(char));  if (fileName == NULL)    mexErrMsgTxt("Not enough heap space to hold converted string.");  status = mxGetString(prhs[0], fileName, buflen);   if (status != 0)    mexErrMsgTxt("Could not convert string data.");  dims[0] = (int)(mxGetScalar(prhs[1]));  dims[1] = (int)(mxGetScalar(prhs[2]));  if (nrhs >=4)  /* if type is specified, then read it, and calculate its */  /* size in bytes, if not assume short int                */    {      buflen = (mxGetM(prhs[3])*mxGetN(prhs[3]))+1;      type = mxCalloc(buflen, sizeof(char));            if (type == NULL)	mexErrMsgTxt("Not enough heap space to hold converted string.");      status = mxGetString(prhs[3], type, buflen);      if (status != 0)	mexErrMsgTxt("Could not convert string data.");      /* Get the ID corresponding to the Matlab type       */      mxClass = GetClassID(type);    }  else    {      type = mxCalloc(6,1);      sprintf(type,"mxUINT16_CLASS");      mxClass = mxUINT16_CLASS;    }  if (nrhs >=5)    invert  = (int)(mxGetScalar(prhs[4]));  else    invert =0;  if (nrhs >=6)    offset  = (int)(mxGetScalar(prhs[5]));  else    offset =0;  plhs[0] = mxCreateNumericArray(ndim,dims,mxClass,mxREAL);  file = fopen(fileName,"rb");  if (file==NULL)    {      sprintf(str,"Opening problem with file : %s",fileName);      mexErrMsgTxt(str);    }  if (offset!=0)    {      if (!fread((void*)mxGetPr(plhs[0]),mxGetElementSize(plhs[0]),offset,file))	{	  sprintf(str,"Reading problem with file : %s",fileName);	  mexErrMsgTxt(str);	}    }        if (!fread((void*)mxGetPr(plhs[0]),mxGetElementSize(plhs[0]),dims[0]*dims[1],file))    {      sprintf(str,"Reading problem with file : %s",fileName);      mexErrMsgTxt(str);    }    if (invert==1)    {      ptr = (unsigned char*)mxGetPr(plhs[0]);                 for (i=0;i<dims[0]*dims[1]*sizeInOctets-1;i+=2)	{	  k++;	  memcpy(&c,&ptr[i+1],1);	  memcpy(&ptr[i+1],&ptr[i],1);  	  memcpy(&ptr[i],&c,1);	}    }fclose(file);}mxClassID GetClassID(char *type){char str[256];  if (strcmp(type,"uchar")==0)    {      return mxCHAR_CLASS;    }  else    if (strcmp(type,"uint16")==0)    {      return mxUINT16_CLASS;    }    else      if (strcmp(type,"uint32")==0)	{	  return mxUINT32_CLASS;	}      else	{	  sprintf(str,"Data type %s not supported by Fast Reader\n",type);	  mexErrMsgTxt(str);	}  return 1;}