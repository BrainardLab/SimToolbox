function [error,g] = FindXXMAPFun(xp,y,colorPriors,sensors,loss)% [error,g] = FindXXMAPFun(xp,y,colorPriors,sensors,loss)%% Error function for FindXMap%% 8/28/94		dhb		Added comments.% 11/7/94		dhb		Changed name, handle T_physical differently.% 11/10/94	dhb		Return some information even for infeasible solutions.% 12/14/94	dhb		Re-wrote after POS version.% 12/20/94	dhb		Again make it like POS version.% 1/2/95		dhb		Re-wrote after POS version (again).% 1/7/95		dhb		Constraint penalty term.% 1/8/95		dhb		Unpack problem parameters.% 10/13/95	dhb		Handle case where g is NaN/Inf.  Don't know%									why this happens, but it does sometimes.% 11/1/95		dhb		More NaN/Inf protection.% 11/3/95		dhb		Additive penalty term, not multiplicative.% 11/9/95		dhb		Make g = max(penalty) to reduce dimensinality.%									More protection of g entries.% 7/28/02   dhb   Update to match FindXLMFun.% 9/6/02    dhb   Get rid of wavelength restriction on expansion.% If this is set to 1, the routine enforces% the realizabilty contraints.ENFORCE_REALIZABILITY = 1;% Convert x to linear if necessary.  x = BCCPolarToLinearCC(xp) ;% Get some sizesN_x = 1;[nil,N_beta] = size(y);% Find the beta implied by x and our desire to % search along the "ridge."A_x = BCCComputeA_x(x,N_x,colorPriors.light.B,N_beta,colorPriors.sur.B,sensors.R); beta = (A_x\y(:));% Compute the statistic to minimize.xPost = BCCComputeXPost(x,y,colorPriors,sensors,loss);% Compute physical realizability terms.  Try to do% it in such a way that search leads towards better% solutions.%% Note that ComputeJointPost can also return penalty,% but it isn't convenient because we want to kluge% in for the fact that our B_surface is only defined% over part of the wavelength range.[T_posX,penalty1] = BCCComputePosTerm(x,loss.pTol,N_x,colorPriors.light.B);[T_physBeta,penalty2] = BCCComputePhysTerm(beta,loss.pTol,N_beta,colorPriors.sur.B);T_physical = T_posX*T_physBeta;[m1,n1] = size(penalty1);[m2,n2] = size(penalty2);penalty = [reshape(penalty1,1,m1*n1) , reshape(penalty2,1,m2*n2)];% Compute an addend for the objective function based on% the penalty term.  This is designed to help prevent the% constr routine from getting stuck.  The scaling is chosen% to make the penalty about the right order relative to% the objective function.index = find( (penalty > 0) & ~isinf(penalty) );addTermRaw = sum(penalty(index));if (ENFORCE_REALIZABILITY == 0)	addTerm = 0;else	if (addTermRaw < 1)		addTerm = addTermRaw^2;	else		addTerm = addTermRaw^2;	endend% Compute error and make sure it is a good value.if (xPost <= 0)	error = 2000;else	error = -log(-xPost) + addTerm;	if (isnan(error) | isinf(error))		error = 2000;	endend% Return constraint vectorif (ENFORCE_REALIZABILITY == 0)	g = -1;else	g = max(penalty);	index = find( g > 2000 | isnan(g) | isinf(g) );	g(index) = 2000*ones(size(index));end