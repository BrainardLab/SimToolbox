function [prob,maxPostX,theXs,theXPosts] = BCCEvaluateChromPosterior(uv,y,lumFactor,nEvals,colorPriors,sensors,loss)% [prob,maxPostX,theXs,theXPosts] = BCCEvaluateChromPosterior(uv,y,lumFactor,nEvals,colorPriors,sensors,loss)%% Evalute the posterior probability that the illuminant% has a particular CIE uv chromaticity.  Do so by evaluating% integral over intensity.% % 7/18/02  dhb  Wrote it.% 9/6/02   dhb  Get rid of wavelength restriction on expansion.% 9/8/02   dhb  Add k^2 to integrand.% 08/15/03 dhb  Convert to uv rather than xy% Say hi%fprintf('Evaluating chromaticity posterior\n');% Convert uv to normalized weights.  I think it makes% more sense to integrate over intensity in weight spaceuvY = [uv ; 1];XYZ = uvYToXYZ(uvY);M_XYZToIllumWeights = inv(colorPriors.light.MToXYZ(:,1:3));x = M_XYZToIllumWeights*XYZ;xNorm = x/norm(x);N_x = 1;% Check that illuminant is all positive[T_posX,penalty1] = BCCComputePosTerm(xNorm,loss.pTol,N_x,colorPriors.light.B);if (~T_posX)	%fprintf('Illuminant reconstructed at passed chromaticity is not all postive\n');	prob = NaN;	maxPostX = NaN;	theKs = [];	theXPosts = [];	return;end % Find minimum illuminant intensity consistent with sensor responses.kMin = BCCFindMinIllumIntensity(xNorm,y,loss.pTol,colorPriors,sensors);if (isnan(kMin))	prob = NaN;	maxPostX = NaN;	theKs = [];	theXPosts = [];	return;end% Evaluate posterior as a function of intensity.[nil,N_beta] = size(y);theKs = linspace(kMin,lumFactor*kMin,nEvals);theXPosts = zeros(size(theKs));for i = 1:length(theKs)	theXPosts(i) = BCCComputeXPost(theKs(i)*xNorm,y,colorPriors,sensors,loss);	% A_x = BCCComputeA_x(theKs(i)*xNorm,N_x,colorPriors.light.B,N_beta,colorPriors.sur.B,sensors.R); 	% beta = (A_x\y(:));	% [T_physBeta,penalty2] = BCCComputePhysTerm(beta,loss.pTol,N_beta,colorPriors.sur.B);	% if (max(penalty2(:)) > 0)	% 	fprintf('Got a feasibility violation where none is expected: i = %d, %d,%g\n',i,T_physBeta,max(penalty2(:)));	% else	% 	if (rem(i,100) == 0)	%		  fprintf('Iteration %d of %d\n',i,length(theKs));	%	  end	% endendprob = (theKs(2)-theKs(1))*trapz((theKs(i).^2) .* theXPosts);theXs = xNorm*theKs;[nil,index] = max(theXPosts);maxPostX = theXs(:,index);% figure(5); clf; plot(theKs,(theKs(i).^2) .* theXPosts,'*'); hold on; drawnow;