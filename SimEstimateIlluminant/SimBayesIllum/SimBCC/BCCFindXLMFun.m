function [error,g] = BCCFindXLMFun(xp,y,colorPriors,sensors,loss)% [error,g] = BCCFindXLMFun(xp,y,colorPriors,sensors,loss)%% Error function for the local mass search procedure.%% 8/28/94		dhb		Wrote it.% 8/31/94		dhb		Finished first draft.% 9/2/94		dhb		Take log to get into reasonable numerical%									range.% 9/4/94		dhb		Incorporate physical realizability.% 9/5/94		dhb		Added check for xLMRisk == 0 case.%						      This can happen if prior gets very%						      small because of finite precision.% 10/30/94	dhb		LMLoss -> LMRisk, which is more correct.% 11/7/94		dhb		Provide some information back even when not%									feasible.% 12/14/94	dhb		Re-wrote after POS version.% 1/2/95		dhb		Re-wrote after POS version (again).% 1/7/95		dhb		Prevent log of 0, add penalty constraint. % 10/13/95	dhb		Handle case where g is NaN/Inf.  Don't know%									why this happens, but it does sometimes.% 11/1/95		dhb		More NaN/Inf protection.% 11/9/95		dhb		Make g = max(penalty) to reduce dimensinality.%									More protection of g entries.% 11/08/98  pxl		Changed names of functions% 12/31/98  dhb   Don't pass NP, just set it here.  Change its name.%                 Deal with new parameter and data formats.% 4/21/99   dhb   Call BCCPolarToLinear, not PolarToLinear.% 7/27/02   dhb   Remove pTol arg, fold into loss.% 9/6/02    dhb   Get rid of wavelength restriction on expansion.% If this is set to 1, the routine enforces% the realizabilty contraints.ENFORCE_REALIZABILITY = 1;% Convert x to linear if necessary.  x = BCCPolarToLinearCC(xp) ;% Get some sizesN_x = 1;[nil,N_beta] = size(y);% Compute the expected loss[xLMRisk,beta] = ...  BCCComputeXLMRisk(x,y,colorPriors,sensors,loss);% Compute physical realizability terms.  Try to do% it in such a way that search leads towards better% solutions.%% Note that ComputeJointPost can also return penalty,% but it isn't convenient because we want to kluge% in for the fact that our B_surface is only defined% over part of the wavelength range.[T_posX,penalty1] = BCCComputePosTerm(x,loss.pTol,N_x,colorPriors.light.B);[T_physBeta,penalty2] = BCCComputePhysTerm(beta,loss.pTol,N_beta,colorPriors.sur.B);T_physical = T_posX*T_physBeta;[m1,n1] = size(penalty1);[m2,n2] = size(penalty2);penalty = [reshape(penalty1,1,m1*n1) , reshape(penalty2,1,m2*n2)];% Compute an addend for the objective function based on% the penalty term.  This is designed to help prevent the% constr routine from getting stuck.  The scaling is chosen% to make the penalty about the right order relative to% the objective function.index = find( (penalty > 0) & ~isinf(penalty) );addTermRaw = sum(penalty(index));if (ENFORCE_REALIZABILITY == 0)	addTerm = 0;else	if (addTermRaw < 1)		addTerm = addTermRaw^2;	else		addTerm = addTermRaw^2;	endend% Compute error and make sure it is a good value.if (xLMRisk >= 0)	error = 2000;else	%error = -log(-xLMRisk)*(1+addTerm);	error = -log(-xLMRisk) + addTerm;	if (isnan(error) | isinf(error))		error = 2000;	endend% Return constraint vectorif (ENFORCE_REALIZABILITY == 0)	g = -1;else	g = max(penalty);	index = find( g > 2000 | isnan(g) | isinf(g) );	g(index) = 2000*ones(size(index));end				