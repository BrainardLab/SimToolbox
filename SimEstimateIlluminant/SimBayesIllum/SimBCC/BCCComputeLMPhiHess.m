function phiHess = BCCComputeLMPhiHess(x,beta,y,colorPriors,sensors,loss)% phiHess = BCCComputeLMPhiHess(x,beta,y,colorPriors,sensors,loss)%% Compute out the Hessian matrix for the phi% function for the local mass loss function,% using the formulae of equations 5 and 8 of Nature paper.% (april 7 '94,p. 542).  % (See also numerical recipes in c, 2nd edition, p. 682.)%% The original version was based on wtf's notes of 8/17/94, with subsequent modifications.% The new approach (9/22/94) is equivalent to the original% version, but the algebra is simpler.  This will be a double-check% for whether or not the original version is correct.%% 8/30/94      dhb      Started writing it.% 8/31/94      dhb      Finished first draft.% 9/1/94       dhb      Make it correspond to new notes.% 9/2/94       dhb      It might actually be working.% 9/22/94      wtf      Modified this to use the simpler formula.%                         See p. 822b of wtf's red notebook.% 11/08/98     pxl			Changed names of functions.% 12/31/98     dhb      Use structures.  Understand new y format.                                        % Get tau and mu out of epsilontau = loss.epsilon(1);mu = loss.epsilon(2);% Produce the full noise parameters by expanding.N_x = size(y,3);[N_r,N_beta] = size(y);u_n = BCCExpandMean(sensors.u_nk,N_beta);  K_n = BCCExpandCov(sensors.K_nk,N_beta);A_x = BCCComputeA_x(x,N_x,colorPriors.light.B,N_beta,colorPriors.sur.B,sensors.R);A_beta = BCCComputeA_beta(beta,N_x,colorPriors.light.B,N_beta,colorPriors.sur.B,sensors.R);Klbeta = BCCExpandCov(loss.Klbeta_j,N_beta);% Get some useful dimensions[xDim,nil] = size(x);[betaDim,nil] = size(beta);% The consolidated loss functionK_l = [Klbeta zeros(betaDim, xDim) ; zeros(xDim, betaDim) loss.Klx];phiHess = [A_x  A_beta]' * inv(K_n) * [A_x A_beta] + (mu/tau) * inv(K_l);