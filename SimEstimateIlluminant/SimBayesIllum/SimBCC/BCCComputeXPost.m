function post_x = BCCComputeXPost(x,y,colorPriors,sensors,loss)% post_x = BCCComputeXPost(x,y,colorPriors,sensors,loss)%% Compute the marginal posterior for x given the data vector y.%% The normalizing constant is neglected.%% 11/7/94	dhb		Postior not modulated by positivity.% 			dhb		Realizability governed both by x and beta implied by x.% 12/14/94	dhb		Add realizability penalty.% 12/20/94	dhb		Modify realizability penalty.% 7/28/02   dhb     Update for structures.% Compute A_x, which we will needN_x = 1;[nil,N_beta] = size(y);A_x = BCCComputeA_x(x,N_x,colorPriors.light.B,N_beta,colorPriors.sur.B,sensors.R); % Prior termT_prior = BCCComputePriorTerm(x,N_x,colorPriors.light);% Feasibility termT_feas = BCCComputeFeasTerm(A_x,y,sensors.u_nk,sensors.K_nk);% Generic termT_generic = BCCComputeGenericTerm(A_x,N_beta,colorPriors.sur.K,sensors.K_nk) .* ...            BCCComputeExtraTerm(A_x,y,sensors.K_nk,colorPriors.sur.K,colorPriors.sur.u,N_beta);% Multiply out to get the posteriorpost_x = T_prior*T_feas*T_generic;