function [x,f] = BCCFindXChromPost(xStart0,y,colorPriors,sensors,loss)% [x,f] = BCCFindXChromPost(xStart0,y,colorPriors,sensors,loss)%% Find the point that maximizes posterior probability over chromaticity.%% 9/2/02      dhb   Wrote it.% 8/15/03     dhb   Convert to uv from xy.% 8/18/03     dhb, bx  Try to convert to new optimization toolbox.% 8/19/03     dhb   Simplify, only one starting point.% 8/3/05      dhb   Return values minimized.fprintf('BCCFindXChromPost:\n');% Find starting points% [theXs,theuvYs] = BCCFindStartingPoints(xStart0,xStart1,y,colorPriors,sensors,loss);% nXs = size(theXs,2);nXs = 1;theuvYs = XYZTouvY(colorPriors.light.MToXYZ*xStart0);% Search options.  Set options(1) to 1 for printout.% options = foptions;% options(1) = 0;% options(2) = 5e-2;% options(3) = 5e-2;% options(4) = loss.pTol/10;% options(14) = 300;options = optimset;options = optimset(options,'Diagnostics','off','Display','off');options = optimset(options,'LargeScale','off');uv0 = theuvYs(1:2,1);[f0] = BCCFindXChromPostFun(uv0,y,colorPriors,sensors,loss);fprintf('\tStarting from uv = %g, %g\n',uv0(1),uv0(2));fprintf('\tInitial loss 1, f = %g\n',f0);	uv1 = fminunc('BCCFindXChromPostFun',uv0,options,y,colorPriors,sensors,loss);[f1] = BCCFindXChromPostFun(uv1,y,colorPriors,sensors,loss);fprintf('\tAfter search, f = %g\n',f1);fprintf('\tAfter search, uv = %g, %g\n\n',uv1(1),uv1(2));uv = uv1;f = f1;% Now loop through and see if we can do better from somewhere else.	% for i = 2:nXs% 	uv0 = theuvYs(1:2,i);% 	[f0,g0] = BCCFindXChromPostFun(uv0,y,colorPriors,sensors,loss);% 	fprintf('\tStarting from uv = %g, %g\n',uv0(1),uv0(2));% 	fprintf('\tInitial loss %d, f = %g, g = %g\n',i,f0,MatMax(g0));	% 	%uv1 = constr('BCCFindXChromPostFun',uv0,options,[],[],[],y,colorPriors,sensors,loss);%     uv1 = fminunc('BCCFindXChromPostFun',uv0,options,y,colorPriors,sensors,loss);% 	[f1,g1] = BCCFindXChromPostFun(uv1,y,colorPriors,sensors,loss);% 	fprintf('\tAfter search, f = %g, g = %g\n',f1,MatMax(g1));% 	fprintf('\tAfter search, uv = %g, %g\n',uv1(1),uv1(2));% 	if (f1 < f & MatMax(g1) < loss.pTol)% 		uv = uv1;% 		f = f1;% 		g = MatMax(g1);	% 	end% 	fprintf('\tBest loss so far, f = %g, g = %g\n\n',f,g);% end% Convert uv back to weightsx = inv(colorPriors.light.MToXYZ)*uvYToXYZ([uv ; 1]);