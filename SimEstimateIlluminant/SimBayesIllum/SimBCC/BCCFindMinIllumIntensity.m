function k = BCCFindMinIllumIntensity(xNorm,y,pTol,colorPriors,sensors)% k = BCCFindMinIllumIntensity(xNorm,y,pTol,colorPriors,sensors)% % Find the constant k such that k*xNorm represents the minimum% illuminant intensity consistent with the sensor responses% and physical realizability of surfaces.%% Return NaN if realizability is not possible for any positive k.%% Passed x should have a vector length of 1.%% 7/25/02  dhb  Wrote it.% 9/6/02   dhb  Rewrite more intelligently.% 9/8/02   dhb  Use linearity in k to speed computation of betaHat in iterations.% 8/18/03  dhb, bx  Got rid of redundant pre-check.% Set parametersN_x = 1;[nil,N_beta] = size(y);% Check that light is realizable.   This checks whether there is a scaling% of the illuminant that leads to a) an all positive illuminant spd and b) all% positive surface srf's consistent with the illuminant and sensor data.% If not we can return NaN without doing anything more.[T_realizable] = BCCCheckXRealizable(xNorm,y,pTol,colorPriors,sensors);if (~T_realizable)	k = NaN;	return;end% Find an initial guess for k that is realizable on the upper end.  Such a k must% exist. (By upper end is meant the constraint that surfaces don't reflect more % light than is incident at any wavelength.)k = 1;A_xHat0 = BCCComputeA_x(xNorm,N_x,colorPriors.light.B,N_beta,colorPriors.sur.B,sensors.R);				betaHat0 = (A_xHat0\y(:));while (1)	% A_xHat = BCCComputeA_x(k*xNorm,N_x,colorPriors.light.B,N_beta,colorPriors.sur.B,sensors.R);					% betaHat = (A_xHat\y(:));	betaHat = betaHat0/k;	[nil,nil,nil,T_greater] = BCCComputePhysTerm(betaHat,pTol,N_beta,colorPriors.sur.B);	if (T_greater == 1)		break;	end	k = 2*k;end%fprintf('Found k = %g is OK\n',k);% By dropping k until there is an upper end problem.while (1)	% A_xHat = BCCComputeA_x(k*xNorm,N_x,colorPriors.light.B,N_beta,colorPriors.sur.B,sensors.R);					% betaHat = (A_xHat\y(:));	betaHat = betaHat0/k;	[nil,nil,nil,T_greater] = BCCComputePhysTerm(betaHat,pTol,N_beta,colorPriors.sur.B);	if (T_greater == 0)		break;	end	k = k/2;endk = 2*k;%fprintf('Found k within factor of 2 = %g\n',k);% Use constr to find the minimum satisfactory koptions = optimset;options = optimset(options,'Diagnostics','off','Display','off');options = optimset(options,'LargeScale','off');oldWarning = warning('off');k = fmincon('BCCFindMinIllumIntensityFun',k,[],[],[],[],0,k,'BCCFindMinIllumIntensityCon',options,xNorm,y,pTol,colorPriors,sensors,betaHat0);warning('oldWarning');k = 1.001*k;%fprintf('Found minimum k = %g\n',k);% A_xHat = BCCComputeA_x(k*xNorm,N_x,colorPriors.light.B,N_beta,colorPriors.sur.B,sensors.R);				% betaHat = (A_xHat\y(:));% [T_phys,penalty] = BCCComputePhysTerm(betaHat,pTol,N_beta,colorPriors.sur.B);%fprintf('k: T_phys = %g, max penalty = %g\n',T_phys,max(penalty(:)));% A_xHat = BCCComputeA_x(1.001*k*xNorm,N_x,colorPriors.light.B,N_beta,colorPriors.sur.B,sensors.R);				% betaHat = (A_xHat\y(:));% [T_phys,penalty] = BCCComputePhysTerm(betaHat,pTol,N_beta,colorPriors.sur.B);%fprintf('1.001*k: T_phys = %g, max penalty = %g\n',T_phys,max(penalty(:)));