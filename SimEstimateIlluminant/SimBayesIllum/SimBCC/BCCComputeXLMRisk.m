function [xLMRisk,betaHat,T_physical,penalty] = BCCComputeXLMRisk(xHat,y, ...	colorPriors,sensors,loss)% [xLMRisk,betaHat,T_physical,penalty] = BCCComputeXLMRisk(xHat,y, ...% 	colorPriors,sensors,loss)%% Compute the local mass loss function for the passed xHat,% following wtf's notes of 8/17/94 with subsequent% modifications.%% Notice that we have a bit of a notational divergence.% In the code, x refers to the old "of interest" variable,% while beta refers to the "generic" variable.  Our new% thinking doesn't make this sharp distinction, and% notes are now written in terms of e and s. I'm sticking% with x and beta for consistency with the entire % previous implementation.%% The routine is currently written so that only xHat is passed.% Strictly, this makes no sense, since the loss depends both% on xHat and on betaH.  We only know how to evaluate the risk,% however, for (xHat,betaHat) that are exactly consistent with% the data.  In the limit of no observation noise, which is% the approximation we are using, it makes sense that the% minimum risk (xHat,betaHat) should explain the data completely.% When the number of sensor equals the number of degrees of% freedom in beta_i, then there is a unique betaHat implied% by xHat, and we can find it.  If there are more or fewer% degrees of freedom in beta_i than there are sensors, we% need to put in a little more thought.  One possibility is% to pass at least part of betaHat to this routine.  The % equality case is of sufficient interest that I would like% to get it working before struggling with the more% complicated situation.%% 8/28/94		dhb		Started work on it.% 8/30/94		dhb		More work on it.% 8/31/94		dhb		Finished first draft.% 9/2/94		dhb		Maybe it works now.% 9/4/94		dhb		Compute and return physical realizability constraint.% 10/30/94	dhb		Change name and var names XLMLoss -> XLMRisk.% 12/14/94	dhb		Add realizability penalty.% 12/20/94	dhb		Modify realizability penalty as a vector.% 11/08/98  pxl		Changed names of functions.% 12/31/98  dhb   Modified for new parameters, data format.%           dhb   Removed debugging calculations, mainly because%                 I didn't want to convert those routines to new%                 format, and in any case they aren't in the simulator.% 7/27/02   dhb   Remove pTol arg, fold into loss.% Set some parametersN_x = 1;[nil,N_beta] = size(y);				% Get tau and mu out of epsilontau = loss.epsilon(1);mu = loss.epsilon(2);% Compute A_xHat, which we will needA_xHat = BCCComputeA_x(xHat,N_x,colorPriors.light.B,N_beta,colorPriors.sur.B,sensors.R);% Find the betaHat implied by xHat and our desire to % search along the "ridge."  See header comment.  This% allows us simply to set x0 and beta0 as well.betaHat = (A_xHat\y(:));x0 = xHat;beta0 = betaHat;% One nice feature of evaluating along the "ridge" is% that phi(x0,beta0) vanishes, so we don't need to % evaluate it. expPhi0 = 1;% We do need to evaluate the contribution of the prior,% which enters the expansion through g(x0,beta0).% disp('		Evaluating g0');g0x = BCCComputePriorTerm(x0,N_x,colorPriors.light);g0beta = BCCComputePriorTerm(beta0,N_beta,colorPriors.sur);g0 = g0x*g0beta;% We also need to evaluate the HessianphiHess = BCCComputeLMPhiHess(x0,beta0,y,colorPriors,sensors,loss);sqrtDetPhiHess = sqrt(abs(det(phiHess)));% Put it all together[totalDim,nil] = size( [x0 ; beta0] );xLMRisk = (-1/sqrtDetPhiHess) *...				( (2*pi/tau)^(totalDim/2) ) * ...				expPhi0 * ...				g0;% Compute physical realizability terms.  Try to do% it in such a way that search leads towards better% solutions.[T_posX,penalty1] = BCCComputePosTerm(xHat,loss.pTol,N_x,colorPriors.light.B);[T_physBeta,penalty2] = BCCComputePhysTerm(betaHat,loss.pTol,N_beta,colorPriors.sur.B);T_physical = T_posX*T_physBeta;penalty = [penalty1 , penalty2];