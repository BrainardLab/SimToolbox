function [outputImage,estimatedIlluminant,S,buchsEstimate] = SimBayesIllum(inputImage,priorsFileName,...    N_beta,N_trials,grayWorldScalesMean,scaleNoise,weightF)% [outputImage,estimatedIlluminant,S, buchsEstimate] = SimBayesIllum(inputImage,priorsFileName,...%          N_beta,N_trials,grayWorldScalesMean,[scaleNoise],[weightF])%% Estimates illuminant using Brainard/Freeman color constancy algorithm.%% 	+ N_beta should be less than 20 (for memory reasons).% 	+ N_trials will allow you to get a better estimate but will multiply the run-time.% 	+ grayWorldScalesMean is used to recenter and rescale the algorithm when the scene%			is not in the range of the priors (eg when the illuminant power is not well described by the priors).%% The estimated illuminant is put in a field of the image structure called estimatedIlluminant%% 08/03/98   pxl Wrote it from dhb's RunIt.m% 11/07/98   pxl Introduced new functions names, Comments%            pxl Changed output from image to illuminant% 11/15/98   pxl Changed order of some paramters to be consistent with other functions% 11/25/98   pxl Changed ouput to image+field% 12/29/98   dhb Variable name changes.  Get rid of illuminant dump.% 12/29/98   dhb Convert sensors so that they relate to physical units.% 12/30/98   dhb Convert to use structures, not packed parameters.%            dhb Change input argument order.%            dhb Get rid of screen saver stuff.  Could be done at%                top level calling script if desired.% 12/31/98   dhb Accept priors as struct as well as filename.%            dhb Rewrite prior scaling to use gray world algorithm.%            dhb Return estimated illumnant as well as image.%            dhb Assume N_x is 1.  Can generalize with multidimensional matrices later%                if desired.%            dhb Allow camera to be passed as a struct.%            dhb Use second arg to mean to force column mean, remove conditional.%            pxl Added scaleNoise parameter (optional) to allow noise%            covariance scaling in the case of averaged data use.% 01/05/01   pxl Modified to return illuminant only.% 01/05/01   pxl Modified to return Buchsbaum estimate as well.% 04/11/01   dhb Add check for Optimization Toolbox.% 6/26/02    dhb Put back return of image structure, memory is cheap.%            dhb Use loss functions that are independent of prior -- spheres in weight space.% 6/26/02    dhb Estimate noise level as function of image, not priors.%            dhb Handle normalChrom prior type in initial guess.% 7/27/02    dhb Remove pTol as arg to FindXLM, fold into loss structure.% 8/18/03    dhb Convert xy to uv.% 2/10/07    dhb Convert for Optimization Toolbox 2.0.%            dhb Handle default for weightF.%            dhb Argument quantizedDraw was no longer used, removed it.% Force N_trials to 1.  The code doesn't actually handle the general case.N_trials = 1;% Check for needed optimization toolbox.  Stop here if it% is not present.if (exist('fmincon') ~= 2)    fprintf('Bayes method requires Mathworks'' Optimization Toolbox.\n')    fprintf('Running only GrayWorld and returning NaN for Bayesian estimate.\n')    error('Aborting');end% Standard image readif (isstruct(inputImage))    outputImage = inputImage;else    outputImage = SimReadImage(inputImage);endclear inputImageif (~isstruct(outputImage.cameraFile))    camera = SimReadCamera(outputImage.cameraFile);else    camera = outputImage.cameraFile;endR = SimAdjustSensors(outputImage,camera);[N_r,null] = size(R);% Load priorsif (isstruct(priorsFileName))    colorPriors = priorsFileName;else    colorPriors = SimLoadColorPriors(priorsFileName);endS = colorPriors.S;if ((nargin<6) | (isempty(scaleNoise)))    scaleNoise=1;endif ((nargin<7) | isempty(weightF))    weightF.stddev = 10e6;end% Compute sensor response of mean surface under mean light.% I do this by computing the response to the mean surface under% the mean light.  This isn't quite right, but it turns out to% come pretty close to the true answer as computed by Monte Carlo.%u_y = R*diag(colorPriors.light.B*colorPriors.light.u)*colorPriors.sur.B*colorPriors.sur.u;u_y = zeros(size(R,1),1);for i = 1:size(R,1)    temp = outputImage.images(:,:,i);    u_y(i) = mean(temp(:));end% Compute gray world estimate.  This is useful for scaling% the priors and for choosing an algorithm startint point.[nil,buchsEstimate] = SimGrayWorldIllum(outputImage,colorPriors);x_buchs = colorPriors.light.B\buchsEstimate;if (grayWorldScalesMean)    scaleFactor = colorPriors.light.u\x_buchs;    u_light = colorPriors.light.u*scaleFactor;    K_light = colorPriors.light.K*(scaleFactor^2);end% Create algorithm prior from true prior.  This allows% us to explore scaling of covariance matrices, should% we wish.  The principled thing to do is set the% fractions to unity.xPriorFrac = 1;betaPriorFrac = 1;algPriors.light = colorPriors.light;algPriors.sur = colorPriors.sur;algPriors.S = colorPriors.S;% Noise parameters.noiseFrac = 0.01;u_nk = zeros(N_r,1);K_nk = (noiseFrac*diag(u_y)).^2;sensors.R = R;sensors.u_nk = u_nk;sensors.K_nk = K_nk/scaleNoise;% Local mass loss function parameters.  Just use spheres in weight space.lossFrac = 1;lossEcc = 1;tau = 1e5;mu = 100;rawKlx = eye(size(colorPriors.light.B,2));rawKlbeta_j = eye(size(colorPriors.sur.B,2));loss.Klx = lossFrac*rawKlx/lossEcc;loss.Klbeta_j = lossFrac*rawKlbeta_j*lossEcc;loss.epsilon = [tau mu]';loss.pTol = 0.001;% Get a random sample of data.[theData,points] = SimDrawPoints(outputImage,N_beta,N_trials,weightF);% Do it N_trials timesM_x = size(algPriors.light.B,2);x_ALGs = zeros(M_x,N_trials);xyY_ALGs = zeros(M_x,N_trials);for l = 1:N_trials    yAvg = mean(theData,2);    u_surface_spd = colorPriors.sur.B*colorPriors.sur.u;    RS = R*diag(u_surface_spd);    buchsEstimate = colorPriors.light.B*((RS*colorPriors.light.B)\yAvg);    x_Buchs = (RS*colorPriors.light.B)\yAvg;    switch (colorPriors.light.priorType)        case 'truncNormalWeights',            x_ALG = BCCFindXLM(colorPriors.light.u,x_buchs,theData, ...                algPriors,sensors,loss);        case 'normalChrom',            buchs_uvY = XYZTouvY(colorPriors.light.MToXYZ*x_buchs);            u_uvY = [colorPriors.light.u ; buchs_uvY(3)];            x0 = inv(colorPriors.light.MToXYZ)*uvYToXYZ(u_uvY);            x_ALG = BCCFindXLM(x0,x_buchs,theData, ...                algPriors,sensors,loss);        otherwise,            error('Unsupported light prior type');    end    x_ALGs(:,l) = x_ALG;end% Get mean answer and return.estimatedIlluminant = colorPriors.light.B*mean(x_ALGs,2);S = colorPriors.S;outputImage.estimatedIlluminant.spd = estimatedIlluminant;outputImage.estimatedIlluminant.S = S;