function [outputImage,estimatedIlluminat,S] = SimSubspaceIllum(inputImage,colorPriors)% [outputImage,estimatedIlluminat,S] = SimSubpaceIllum(inputImage,colorPriors)%% Use Maloney and Wandell's algorithm to estimate the illuminant.% Algorithm taken from Wandell's 1987 write-up.%% The estimated Illuminant is put in a field of the image structure called% estimatedIlluminant.%% The routine includes a really crude sampling algorithm that will produce% garbage for small images.  Need to use SimDrawPoints.%% 01/12/94    dhb  Created.% 09/15/98    pxl  Modified for Simulator plugin% 11/07/98    pxl  Modified return type% 11/25/98    pxl  Changed return type to structure w estimatedIlluminant.% 12/29/98    dhb  Get rid of third argument, variable name changes.% 12/29/98    dhb  Convert sensors so that they relate to physical units.% 12/31/98    dhb  Change name.  Handle camera struct.  Change return format.%  4/20/99    dhb  Update read style.% Copyright (c) 1999 David Brainard and Philippe Longere.   All rights reserved.% Get the image and camera informationif (isstruct(inputImage))  outputImage = inputImage;else  outputImage = SimReadImage(inputImage); endclear inputImage;if (~isstruct(outputImage.cameraFile))	camera = SimReadCamera(outputImage.cameraFile);else	camera = outputImage.cameraFile;endR = SimAdjustSensors(outputImage,camera);% Load priors.if (isstruct(colorPriors))	colorPriors = colorPriors;else	colorPriors = SimLoadColorPriors(colorPriors);end% Set some sizesM_x = length(colorPriors.light.u);M_beta = length(colorPriors.sur.u);% Find normal to sensor responses% We use the singular value decomposition to% do this.  This is the pi of equation 28.nPoints = 200;nTrials = 1;QUANTIZE = 0;[M_r,nil] = size(R);drawnPoints = SimDrawPoints(outputImage,nPoints,1,QUANTIZE);y = drawnPoints{1}';% images = reshape(outputImage.images,outputImage.height*outputImage.width,M_r); % y = images(1:200:outputImage.height*outputImage.width,:);N_beta = size(y,1);yForSVD = reshape(y,M_r,N_beta);[u,d,v] = svd(yForSVD);pi = u(:,M_r)';% Construct the PI matrix of equation 33.% First step, construct some surface vectors.% Second stage, construct the PI matrix from the vectors.pisur = SimConstructPisur(M_r-1);[null,N_pisur] = size(pisur);PI = zeros(N_pisur,M_x);for i = 1:N_pisur  PI(i,:) = pi * SimConstructLs(pisur(:,i),colorPriors.sur.B(:,1:M_r-1),colorPriors.light.B(:,1:M_r),R);end% Now we solve PI*epsvec = 0, normalizing to 1epsvec = zeros(M_r,1);epsvec(1) = 1;epsvec(2:M_r) = PI(:,2:M_r)\ (-1*PI(:,1));% Expand epsvec to an estimate for x by padding% with zerose = zeros(M_x,1);e(1:M_r,:) = epsvec;% Now choose a scaling for x.  This is not part of the% MW algorithm, but for fairness in the comparisions it% seems like one should do some sort of scaling.% This is a quick and dirty algorithm.  We find the relation% between the mean sensor response of the population and% the mean sensor response of the image.  We scale the estimate% so that its scalar relation to the mean illuminant reflectance is in% the same relation as the mean image response is to the mean population% response.u_y = R*diag(colorPriors.light.B*colorPriors.light.u)*colorPriors.sur.B*colorPriors.sur.u;scale1 = u_y\(mean(reshape(y,M_beta,N_beta)')');scale2 = (colorPriors.light.B*e)\(colorPriors.light.B*colorPriors.light.u);estimatedIlluminant = e*scale1*scale2;estimatedIlluminant = colorPriors.light.B*e;outputImage.estimatedIlluminant.spd = estimatedIlluminant;S = colorPriors.S;outputImage.estimatedIlluminant.S = S;