function [outImage] = SimFastLinearInterp(inImage)% [outImage] = SimFastLinearInterp(inImage)%% A simple and fast linear interpolation to de-mosaic the image.% % 4/13/99   xmz  Wrote it.% 4/19/99   dhb  Cosmetic changes, clear mosaic flag, set bits.% 5/12/99   dhb  Add consistency check, which passes.% 11/04/04  dhb, jmk    Update for MATLAB 7.% SwitchesCHECK_CONSISTENCY = 0;if ( nargin <1 )  error(['SimFastLinearInterp(inImage)']);endif (isstruct(inImage))  outImage = inImage;else  outImage = SimReadImage(inImage); endif (~isstruct(inImage.cameraFile))  camera = SimReadCamera(inImage.cameraFile);else  camera = inImage.cameraFile;end% Only act if image is mosaiced.if (camera.spatialLayout.dims(1)*camera.spatialLayout.dims(2) ~= 1 & ...    inImage.imageType == 'sensor' & inImage.mosaiced == 1 )  % Create mask for the mosaic  masks = SimCreateMask(camera, inImage.height, inImage.width);  for n = 1:camera.numberSensors    % The following filtering gives the    % weighted sum of all neighbors for each pixel. The    % diagonal neighbors get half the weight as the    % non-diagonal neighbors.  The values for the    % non-missing pixels are not meaningful, but we don't need    % them anyway.    f1 = [0.5 1 0.5];    neighbors = conv2(inImage.images(:,:,n), f1, 'same');    neighbors = conv2(neighbors, f1', 'same') - inImage.images(:,:,n);    % This gives the number of neighboring pixels that actually     % had a value (that are sampled on the mosaic). This will    % be used as the denominator for computing the average    % values of neighboring pixels for each pixel.    neighborCount = conv2(double(masks(:,:,n)>0), f1, 'same');    neighborCount = conv2(neighborCount, f1', 'same');    % If there is no neighbor with real value, pretend that all     % neighbors are there, to avoid divide-by-zero later    % on. This will result in zero output values for    % neighbor-less pixels. This should not happen for Bayer mosaic.    neighborCount(neighborCount==0) = sum(sum(f1'*f1))-f1(2)*f1(2);         % Divide the sum of neighbor values by the number of    % real neighbors, to get an avarage. This is similar to a    % bilinear interpolation based on neighboring pixels.    neighbors = neighbors./neighborCount;    neighbors(masks(:,:,n)>0) = 0;    neighbors = neighbors + inImage.images(:,:,n);    outImage.images(:,:,n) = neighbors;  end    % Clear mosaiced flag  outImage.mosaiced = 0;  outImage.bits = Inf;   % Check that linear interpolation does the right thing  % where there are actally sensors  if (CHECK_CONSISTENCY)    if (any(outImage.images .* masks ~= inImage.images))      fprintf('Linear reconstruction fails to return samples\n');    else      fprintf('Linear reconstruction OK\n');    end  endelse  % Image was not mosaiced, just pass on by.    outImage = inImage;end