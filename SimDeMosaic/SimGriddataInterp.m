function [outImage] = SimGriddataInterp(inImage,method)% [outImage] = SimGriddataInterp(inImage,[method])%% Interpolates the mosaiced inImage file, using% MATLAB griddata function for interpolation.%% Optional method (default = 'nearest') is passed% to griddata.  Other options are 'linear', 'cubic',% and 'v4'.  The problem is that some of these% methods return NaN (presumably near the edges)% and this really screws up further processing.% This could be handled, either by cropping the image% here or by inserting values obtained in some other% way for the NaN values.%% 10/30/98  dhb  Added comments.% 10/31/98  pxl  More comments, added the call to%                SimCreateMask% 11/9/98   dhb  Allow cameraFile to be a struct or filename.%						dhb	 Handle files that are already demosaiced.%						dhb  Separate input and output file names.% 11/13/98  dhb  Change inputImage to inImage.% 1/19/99   dhb  Remover history update.% 4/17/99   dhb  Add optional method, but note comment above.% 4/19/99   dhb  Cosmetic.% 11/16/04  dhb, jaw, jmk   Fix this.% Copyright (c) 1999 David Brainard and Philippe Longere.   All rights reserved.% Check argsif (nargin < 1 | nargin > 2)    error(['SimGriddataInterp(inImage,[method])']);end% Set default method.if (nargin < 2)    method = 'linear';end% Standard inputif (isstruct(inImage))    outImage = inImage;else    outImage = SimReadImage(inImage);endif (~isstruct(inImage.cameraFile))    camera = SimReadCamera(inImage.cameraFile);else    camera = inImage.cameraFile;end% Only act if image is mosaiced.if (camera.spatialLayout.dims(1)*camera.spatialLayout.dims(2) ~= 1 & ...        inImage.imageType == 'sensor' & inImage.mosaiced == 1 )    % Calculate the dimemsions of the mask to be used    % if the image is not too big, do it in one pass    % if not do it line by line but this has to be debugged    % and is never called.    mask = SimCreateMask(camera,inImage.height,inImage.width);    [x y] = meshgrid(1:inImage.height,1:inImage.width);    for n = 1:camera.numberSensors        maskPlane = mask(:,:,n);        imagePlane = inImage.images(:,:,n);        [x1 y1] = find(maskPlane == 1);        index = find(maskPlane == 1);        z1 = imagePlane(index);        fprintf('SimGriddataInterp: Calling griddata on plane %g\n',n);        outImage.images(:,:,n) = griddata(x1,y1,z1,x,y,method)';    end    % Clear mosaiced flag    outImage.mosaiced = 0;    outImage.bits = Inf;    % Image was not mosaiced, just pass on by.else    outputImage = inImage;end