function [outImage] = SimFreemanInterp(inImage,filterSize)% [outImage] = SimFastLinearInterp(inImage,filterSize)%% William Freeman's demosaicing algorithm.  Patented% by Polaroid.% % 4/23/99   dhb  Wrote it from wtf's desription.% 5/12/99   dhb  Improved algorithm based on WTF suggestions after%								 he read my first try.% ParametersINCONSISTENT_METHOD = 0;% Check args and fill in defaults.if ( nargin < 1 )  error(['SimFreemanInterp(inImage,[filterSize])']);endif (nargin < 2 | isempty(filterSize))	filterSize = 5;end% Standard image read sequence.if (isstruct(inImage))  outImage = inImage;else  outImage = SimReadImage(inImage); endif (~isstruct(inImage.cameraFile))	camera = SimReadCamera(inImage.cameraFile);else	camera = inImage.cameraFile;end% Only act if image is mosaiced.if (camera.spatialLayout.dims(1)*camera.spatialLayout.dims(2) ~= 1 & ...	  inImage.imageType == 'sensor' & inImage.mosaiced == 1 )	% Initial linear interpolation	linearImage = SimFastLinearInterp(inImage);  % Create mask for the mosaic  masks = SimCreateMask(camera,inImage.height,inImage.width);			% Loop through and fill in with via the median filtered difference images.	if (INCONSISTENT_METHOD)		outImage.images = zeros(size(inImage.images));	  for n = 1:camera.numberSensors			for m = 1:camera.numberSensors				% Take difference between mth and nth image				if (m ~= n)					diffImage = linearImage.images(:,:,m)-linearImage.images(:,:,n);					diffImage = medfilt2(diffImage,[filterSize filterSize]);					outImage.images(:,:,m) = outImage.images(:,:,m) + ...					 masks(:,:,n).*(diffImage + linearImage.images(:,:,n));				else					outImage.images(:,:,m) = outImage.images(:,:,m) + ...						masks(:,:,n).*linearImage.images(:,:,n);				end			end	  end	else		masterSensor = floor((camera.numberSensors+1)/2);		outImage.images = zeros(size(inImage.images));		for n = 1:camera.numberSensors			if (n ~= masterSensor)				diffImage = linearImage.images(:,:,n) - linearImage.images(:,:,masterSensor);				diffImage = medfilt2(diffImage,[filterSize filterSize]);				outImage.images(:,:,n) = ...					masks(:,:,n) .* inImage.images(:,:,n) + ...				 ~masks(:,:,n) .* (diffImage + linearImage.images(:,:,masterSensor));			else				outImage.images(:,:,n) = linearImage.images(:,:,n);			end		end	end	% Clear mosaiced flag	outImage.mosaiced = 0;	outImage.bits = Inf;else  % Image was not mosaiced, just pass on by.	outImage = inImage;end